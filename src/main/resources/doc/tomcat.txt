tomcat多线程处理及ThreadLocal使用注意

tomcat默认使用线程池来管理线程，即当收到一个请求时，如果线程池存在空闲线程，则会从中取出一个空闲线程来处理该请求。当一个线程在处理请求时，其他请求就不会被分配至该线程。

例如有a,b,c三个空闲线程：
1、当request1到来时，分配a线程来处理
2、同时有request2到来，此时a线程在处理中，因此只有bc两个空闲线程，则会从中选一个处理request2。
3、request1处理完成，request3来了，则就可能分配给空闲线程a来处理。

问题来了，如果项目中使用了ThreadLocal，则在步骤1中会存入a线程对应的数据，步骤2中会存入b线程对应的数据，二者互不干扰。当到步骤3时，
由于复用了线程a，因此request3这个请求处理过程中，可以直接通过ThreadLocal取到步骤1中放入的数据。

因此，在写代码时，注意在请求处理结束之前，把ThreadLocal中存入的数据清空，防止后续线程复用时造成干扰。


########################################################################################################################
Tomcat6使用NIO后对ThreadLocal的影响

很早就听说tomcat6使用nio了，这几天突然想到一个问题，使用nio代替传统的bio，ThreadLocal岂不是会存在冲突？

BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。

这个时候，问题就出来了：我们非常多的java应用是使用ThreadLocal的，例如JSF的FaceContext、Hibernate的session管理、
Struts2的Context的管理等等，几乎所有框架都或多或少地应用ThreadLocal。如果存在冲突，那岂不惊天动地？

后来终于在Tomcat6的文档（http://tomcat.apache.org/tomcat-6.0-doc/aio.html）找到答案。根据上面说明，
应该Tomcat6应用nio只是用在处理发送、接收信息的时候用到，也就是说，tomcat6还是传统的多线程Servlet：
　　　
tomcat5：客户端连接到达 -> 传统的SeverSocket.accept接收连接 -> 从线程池取出一个线程 -> 在该线程读取文本并且解析HTTP协议 ->
在该线程生成ServletRequest、ServletResponse，取出请求的Servlet -> 在该线程执行这个Servlet -> 在该线程把ServletResponse的内容发送到客户端连接 -> 关闭连接。
　　
我以前理解的使用nio后的tomcat6：客户端连接到达 -> nio接收连接 -> nio使用轮询方式读取文本并且解析HTTP协议（单线程） ->
生成ServletRequest、ServletResponse，取出请求的Servlet -> 直接在本线程执行这个Servlet -> 把ServletResponse的内容发送到客户端连接 -> 关闭连接。
　　
实际的tomcat6：客户端连接到达 -> nio接收连接 -> nio使用轮询方式读取文本并且解析HTTP协议（单线程） ->
生成ServletRequest、ServletResponse，取出请求的Servlet -> 从线程池取出线程，并在该线程执行这个Servlet -> 把ServletResponse的内容发送到客户端连接 -> 关闭连接。
　　　　
BIO与NIO的不同，也导致进入客户端处理线程的时刻有所不同：tomcat5在接受连接后马上进入客户端线程，在客户端线程里解析HTTP协议，
而tomcat6则是解析完HTTP协议后才进入多线程，另外，tomcat6也比5早脱离客户端线程的环境。
　　
实际的tomcat6与我之前猜想的差别主要集中在如何处理servlet的问题上。实际上即使抛开ThreadLocal的问题，我之前理解tomcat6只使用一个线程处理的想法其实是行不同的。
大家都有经验：servlet是基于BIO的，执行期间会存在堵塞的，例如读取文件、数据库操作等等。tomcat6使用了nio，但不可能要求servlet里面要使用nio，而一旦存在堵塞，效率自然会锐降。
　　
所以，最终的结论当然是tomcat6的servlet里面，ThreadLocal照样可以使用，不存在冲突。